%h2.heading-green Adding Inline Child Forms on the Parent Form in Javascript -- Inline Child Forms

%p Suppose you are editing a user's record. The user has multiple profiles on many pages, like facebook, google plus, stackoverflow etc, and you also save the user's profile urls as well as usernames on external sites in a different form. You want the user to not just edit his form, you also want the same form to show these profiles for editing, and to let him add more profiles.

%p The above is an example of being able to add/edit child records on the form of the parent model. You have a one-many relationsip between two tables, and you want to be able to make changes to the associated records.

%p This can be handled quite well in javascript. There may be two techniques to achieve the above. One is to do it without injecting javascript into the page and rely on attributes for the functionality. The other is to inject javascript into the page.

%p 
  We will cover the latter technique in this tutorial. The latter technique is described quite well in 
  = link_to("Railscasts episode 196", "http://railscasts.com/episodes/196--nested-model-form-part-1")
  and
  = link_to("Railscasts episode 197", "http://railscasts.com/episodes/197-nested-model-form-part-2")
  \. This tutorials is more of a commentary on it, in order to make myself and others understand the nitty gritty details.

%p So to list what we want, we want the following functionality:
%ul
  %li user can edit existing profiles
  %li user can add more profiles
  %li user can remove an existing profile

%p In order to add or edit profiles, we need the user model to be able to save associated profiles. This by default is turned off for security purposes. We need to enable it. This enabling is model-side code. It can be done as follows:

%h3.green 1. Changes to the User Model(parent model).
%pre
  class User
  \  has_many :user_profiles, :dependent => :destroy
  \  accepts_nested_attributes_for :user_profiles, :reject_if => lambda { |attrs| attrs[:name].blank? },
  \                                :allow_destroy => true
  \  attr_accessible :user_profiles_attributes
  end

%p The above enables one to save new user profiles if they are present appropriately in the params hash, to edit existing user profiles present in the params hash, and also to mark a user profile for deletion. The params hash can send an attribute: "_destroy => true" to the controller, and when you save the user record, it deletes the user profile with the delete attribute set. So the above is building into the model three abilities:
%ul
  %li save a new user profile
  %li edit an old user profile
  %li delete an old user profile

%p Now, to tackle the easier task first: how does one show existing profiles on the user form. This can be done with the following code:

%h3.green 2. List the Already Present User Profiles
%pre
  f.fields_for(:user_profiles) do |up| 
  = h('<p class="fields">')
  \  up.label :profile_name, "Name" 
  \  up.text_field :profile_name  
  \  up.hidden_field :_destroy 
  \  up.hidden_field(:_destroy)
  \  link_to_function(name, "remove_fields(this)", options) 
  = h('</p>')
  end

%p the fields_for helper is an awesome helper. It looks pretty straightforward, but it iterates over each of the associated profiles, and lists the profile name, a hidden field for enabling destroy, and a link to remove the profile for each of the profiles present.

%p What does the rails method link_to_function do? If you look at the generated source code, you realize that it injects the following javascript code into the page:
%pre
  = h('<a onclick="remove_fields(this); return false;" href="#">remove</a>')
%h3.green 3. Javascript remove_fields method

%pre
  function remove_fields(link){
  \  $(link).prev().val("1");
  \  $(link).parent(".fields").hide();
  }

%p Now, using the fields_for helper which lists all profiles in editable forms, a hidden field for toggling _destroy attribute, and a remove_fields method in js that will set its value to true and hide the profile from view, we are able to edit and destroy existing profiles.

%p Now comes the tricky part, which is, how to add user profiles?

%p Once you click on a js button, it needs to inject a new user profile form into the page. This profile form should have the field names as generated by rails, so that once you submit it, the field values are passed into params as if they were submitted from a form generated using form_for. Not just that, but if the user wants to add multiple profiles at once, again, all of them should be present in a way that rails understands.

%p So javascript needs to inject form, but rails knows how to create the form, and not javascript. The solution is to construct the form in rails, and pass the constructed form to a js function that can use it. This involves three pieces of code, which are as follows:

%h3.green 4. Javascript add_fields method

%pre
  function add_fields(link, association, content) {
  \  var new_id = new Date().getTime();
  \  var regexp = new RegExp("new_" + association, "g")
  \  $(link).parent().before(content.replace(regexp, new_id));
  }

%p Basically, rails will generate forms. Since each new profile form needs to be passed into params separately, we will use the new_id above to generate a unique value, which will be used to make each of the content fields associated with the profile different.

%p So rails now has to send the content to the js appropriately, and tell what the association is, so that it can be modified as needed. So what is the rails code?

%h3.green 5. Rails Helper Method
%pre
  def link_to_add_fields(name, f, options = {})
  \  association = options[:association]   
  \  new_object = f.object.class.reflect_on_association(association).klass.new
  \  fields = f.fields_for(association, new_object, :child_index => "new_\#{association}") do |builder|
  \    render(association.to_s.singularize + "_fields", :f => builder)
  \  end
  \  link_to_function(name, "add_fields(this, \"\#{association}\", \"\#{escape_javascript(fields)}\")")
  end

%p Now, we just need to put a link on the page to inject the above js generated by the link_to_add_fields into the page when clicked:

%h3.green 6, Rails View Code
%pre
  link_to_add_fields "Add A Profile", f, :association => :user_profiles

%p Just for fun, the generated js for the above code is as follows:

%pre
  =h('<a onclick="add_fields(this, "user_profiles", "<p class=\"fields\">\n <label for=\"user_user_profiles_attributes_new_user_profiles_profile_name\">Name<\/label>\n <input id=\"user_user_profiles_attributes_new_user_profiles_profile_name\" name=\"user[user_profiles_attributes][new_user_profiles][profile_name]\" size=\"30\" type=\"text\" />\n <label for=\"user_user_profiles_attributes_new_user_profiles_profile_url\">Url<\/label>\n <input id=\"user_user_profiles_attributes..." size=\"30\" type=\"text\" />\n <input id=\"user_user_profiles_attributes_new_user_profiles__destroy\" name=\"user[user_profiles_attributes][new_user_profiles][_destroy]\" type=\"hidden\" value=\"false\" />\n <input id=\"user_user_profiles_attributes_new_user_profiles__destroy\" name=\"user[user_profiles_attributes][new_user_profiles][_destroy]\" type=\"hidden\" value=\"false\" /><a href=\"#\" onclick=\"remove_fields(this); return false;\">remove<\/a>\n<\/p>\n\n"); return false;" href="#">Add A profile</a>')


